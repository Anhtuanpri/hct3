<!doctype html>
<html lang="vi">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>ƒêua V·ªãt v4.0-static ‚Äî assets c·ªë ƒë·ªãnh + l·ª≠a BOOST + obstacle scale</title>
<style>
  :root{
    --bg:#f6f7fb; --panel:#ffffff; --text:#0f172a; --muted:#6b7280;
    --border:#e5e7eb; --accent:#2563eb; --good:#16a34a; --warn:#f59e0b; --danger:#ef4444; --boost:#22c55e;
  }
  *{box-sizing:border-box} html,body{margin:0;height:100%;background:var(--bg);color:var(--text);font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial}
  h1,h2{margin:.2rem 0 .6rem}
  .app{display:grid;grid-template-columns:380px 1fr;gap:14px;padding:14px}
  @media (max-width:1200px){.app{grid-template-columns:1fr}}
  .card{background:var(--panel);border:1px solid var(--border);border-radius:14px;padding:14px;box-shadow:0 1px 2px rgba(0,0,0,.03)}
  .row{display:flex;gap:8px;flex-wrap:wrap}
  input,select,textarea{background:#fff;border:1px solid var(--border);color:#0f172a;border-radius:10px;padding:.55rem .65rem;outline:none}
  input,select{flex:1}
  button{background:#1f2937;border:1px solid #111827;color:#fff;border-radius:10px;padding:.55rem .85rem;font-weight:600;cursor:pointer;transition:.15s}
  button.primary{background:linear-gradient(180deg,#3b82f6,#2563eb);border-color:#1d4ed8}
  button.ghost{background:transparent;border-color:var(--border);color:#111827}
  button:active{transform:translateY(1px)}
  table{width:100%;border-collapse:collapse;margin-top:.4rem}
  th,td{border-bottom:1px dashed var(--border);padding:.35rem .25rem}
  th{text-align:left;color:#334155}
  .scroll{max-height:240px;overflow:auto;border:1px solid var(--border);border-radius:10px;padding:.25rem;background:#fff}
  #raceCanvas{width:100%;height:460px;border-radius:12px;display:block;background:linear-gradient(180deg,#cfe8ff,#e8f3ff)}
  #banner{position:absolute;inset:10px;display:none;align-items:center;justify-content:center;background:rgba(255,255,255,.65);backdrop-filter:blur(4px);border-radius:12px;font-weight:800;font-size:1.05rem;color:#111827;border:1px solid var(--border);pointer-events:none;text-align:center;padding:8px 12px}
  .tiny{font-size:.9rem} .muted{color:#6b7280}
  .pill{background:#eef2ff;border:1px solid #c7d2fe;border-radius:999px;padding:.2rem .55rem;color:#3730a3}
  details summary{cursor:pointer;color:#1d4ed8;margin:.3rem 0}
  .badge{display:inline-block;padding:.15rem .5rem;border-radius:999px;font-weight:700;font-size:.8rem;border:1px solid #cbd5e1;background:#f1f5f9}
  .badge.win{background:#ecfdf5;color:#065f46;border-color:#a7f3d0}
</style>
</head>
<body>
<div class="app">
  <section class="card">
    <h1>ü¶Ü ƒêua V·ªãt v4.0-static</h1>
    <div class="row">
      <label style="flex:1.1">S·ªë v·ªãt
        <input id="numDucks" type="number" min="3" max="8" value="6">
      </label>
      <label>Th·ªùi gian (s, 15s+) ‚Äî c√†ng l√¢u, c√†ng nhi·ªÅu ch∆∞·ªõng ng·∫°i
        <div class="row">
          <input id="minTime" type="number" min="10" max="150" value="15">
          <input id="maxTime" type="number" min="11" max="160" value="18">
        </div>
      </label>
    </div>

    <h2 style="margin-top:.7rem">Ng∆∞·ªùi ch∆°i (t·ªëi ƒëa <b>30 m·ªói v·ªãt</b>)</h2>
    <div class="row">
      <input id="playerName" placeholder="T√™n/ID">
      <select id="duckSelect"></select>
      <button id="addBtn" class="primary">‚ûï Th√™m</button>
      <button id="demoBtn" class="ghost">‚ú® Th√™m demo</button>
    </div>

    <div class="scroll">
      <table>
        <thead><tr><th>Ng∆∞·ªùi ch∆°i</th><th>V·ªãt</th><th></th></tr></thead>
        <tbody id="playersBody"></tbody>
      </table>
    </div>
    <div id="countInfo" class="tiny muted" style="margin-top:.3rem"></div>

    <details>
      <summary>Nh·∫≠p nhanh (m·ªói d√≤ng: <b>t√™n, s·ªë_v·ªãt</b>)</summary>
      <textarea id="bulkInput" placeholder="An, 1&#10;B√¨nh, 3&#10;T√∫n, 2"></textarea>
      <div class="row">
        <button id="bulkBtn">üì• N·∫°p</button>
        <button id="clearBtn" class="ghost">üßπ Xo√° c∆∞·ª£c</button>
      </div>
    </details>

    <div class="row" style="margin-top:.6rem">
      <button id="startBtn" class="primary">üé¨ B·∫Øt ƒë·∫ßu</button>
      <span class="pill" id="laneInfo">‚Äî</span>
    </div>
    <div class="tiny muted" style="margin-top:.4rem">
      √Çm thanh: ƒë·∫∑t <b>1.mp3</b> / <b>2.mp3</b> c√πng th∆∞ m·ª•c. N·∫øu thi·∫øu, game ph√°t ti·∫øng ‚Äúbeep‚Äù.
    </div>
  </section>

  <section class="card" style="position:relative">
    <canvas id="raceCanvas"></canvas>
    <div id="banner"></div>
  </section>
</div>

<div style="display:grid;grid-template-columns:1fr 1fr;gap:14px;padding:0 14px 14px">
  <section class="card">
    <h2>üßæ Nh·∫≠t k√Ω th·∫Øng cu·ªôc</h2>
    <div class="tiny muted">M√∫i gi·ªù Asia/Ho_Chi_Minh</div>
    <ul id="logList"></ul>
  </section>
  <section class="card">
    <h2>üìä B·∫£ng t√≠ch lu·ªπ xu</h2>
    <div class="row" style="margin-bottom:.4rem">
      <button id="exportScoreBtn" class="ghost">üì§ Xu·∫•t CSV</button>
      <button id="resetScoreBtn" class="ghost">‚ôªÔ∏è Reset b·∫£ng</button>
    </div>
    <div class="scroll">
      <table>
        <thead><tr><th>Ng∆∞·ªùi ch∆°i</th><th>T·ªïng xu</th><th>VIP</th></tr></thead>
        <tbody id="scoreBody"></tbody>
      </table>
    </div>
  </section>
</div>

<script>
(function(){
  // ==== CONFIG: ASSETS ====  (D√ÅN LINK ·∫¢NH C·ª¶A B·∫†N ·ªû ƒê√ÇY)
  const ASSETS = {
    // URL m·∫∑c ƒë·ªãnh cho v·ªãt (d√πng n·∫øu v·ªãt #n kh√¥ng c√≥ url ri√™ng). C√≥ th·ªÉ ƒë·ªÉ "" ƒë·ªÉ d√πng h√¨nh v·∫Ω fallback.
    duckDefault: "",

    // URL ri√™ng t·ª´ng v·ªãt (1..8). B·ªè "" ƒë·ªÉ d√πng duckDefault/fallback.
    ducks: {
      1:"", 2:"", 3:"", 4:"", 5:"", 6:"", 7:"", 8:""
    },

    // ·∫¢nh cho ch∆∞·ªõng ng·∫°i + boost (b·ªè "" s·∫Ω d√πng √¥ m√†u + ch·ªØ).
    obstacles: {
      MUD:"",   // v√≠ d·ª• "assets/mud.png" ho·∫∑c "https://.../mud.png"
      OIL:"",
      NET:"",
      WAVE:"",
      CRAB:"",
      BOOST:""  // c√≥ th·ªÉ ƒë·ªÉ ri√™ng h√¨nh boost
    },

    // B·∫≠t l·ª≠a khi d·∫´m boost
    flameOnBoost: true,

    // K√≠ch th∆∞·ªõc sprite (c√≥ th·ªÉ tinh ch·ªânh n·∫øu ·∫£nh c·ªßa b·∫°n to/nh·ªè)
    duckSize: { w: 44, h: 36 },         // ƒë∆°n v·ªã: px ·ªü DPR=1 (s·∫Ω nh√¢n DPR)
    obstacleSize: { w: 28, h: 28 },
    boostSize: { w: 34, h: 20 }
  };
  // ==========================

  // ===== Elements =====
  const numDucksEl = document.getElementById('numDucks');
  const minTimeEl  = document.getElementById('minTime');
  const maxTimeEl  = document.getElementById('maxTime');

  const nameEl     = document.getElementById('playerName');
  const duckSelEl  = document.getElementById('duckSelect');
  const addBtn     = document.getElementById('addBtn');
  const demoBtn    = document.getElementById('demoBtn');
  const bodyEl     = document.getElementById('playersBody');
  const bulkInput  = document.getElementById('bulkInput');
  const bulkBtn    = document.getElementById('bulkBtn');
  const clearBtn   = document.getElementById('clearBtn');
  const countInfo  = document.getElementById('countInfo');
  const startBtn   = document.getElementById('startBtn');
  const laneInfo   = document.getElementById('laneInfo');
  const canvas     = document.getElementById('raceCanvas');
  const banner     = document.getElementById('banner');
  const logList    = document.getElementById('logList');
  const scoreBody  = document.getElementById('scoreBody');
  const exportScoreBtn = document.getElementById('exportScoreBtn');
  const resetScoreBtn  = document.getElementById('resetScoreBtn');

  // ===== State =====
  const TZ='Asia/Ho_Chi_Minh';
  const LS_KEY='duck_race_v40s_scores';
  const state = {
    players: [],
    raceRunning:false,
    audioCtx:null, audio1:null, audio2:null,
    scores: {},
    idle:{race:null},
    cache:{ ducks:[], obstacles:{} }
  };

  // ===== Helpers =====
  function clamp(v,a,b){return Math.max(a,Math.min(b,v))}
  function rand(a,b){return a + Math.random()*(b-a)}
  function randi(a,b){return Math.floor(rand(a,b+1))}
  function escapeHtml(s){return s.replace(/[&<>"]/g, c=>({"&":"&amp;","<":"&lt;","&gt;":"&gt;","\"":"&quot;"}[c]))}
  const norm = s => (s||'').trim().toLowerCase();
  function showBanner(text){ banner.textContent = text; banner.style.display='flex'; }
  function hideBanner(){ banner.style.display='none'; banner.textContent=''; }

  // ===== Scoreboard =====
  function loadScores(){ try{ const raw=localStorage.getItem(LS_KEY); if(raw) state.scores=JSON.parse(raw)||{}; }catch{} renderScores(); }
  function saveScores(){ try{ localStorage.setItem(LS_KEY, JSON.stringify(state.scores)); }catch{} }
  function addScore(name, dx=0, dv=0){ const key=norm(name); if(!key) return; if(!state.scores[key]) state.scores[key]={name, xu:0, vip:0}; state.scores[key].name=name; state.scores[key].xu+=dx; state.scores[key].vip+=dv; }
  function renderScores(){ const arr=Object.values(state.scores).sort((a,b)=> b.xu-a.xu || b.vip-a.vip || a.name.localeCompare(b.name)); scoreBody.innerHTML=arr.map(s=> `<tr><td>${escapeHtml(s.name)}</td><td>${s.xu}</td><td>${s.vip}</td></tr>`).join(''); }
  function exportCSV(filename, rows){ const csv=rows.map(r=>r.map(v=>`"${String(v).replace(/"/g,'""')}"`).join(',')).join('\r\n'); const blob=new Blob([csv],{type:'text/csv;charset=utf-8;'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download=filename; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url); }
  exportScoreBtn.onclick=()=>{ const rows=[['Name','Total Xu','VIP']]; for(const s of Object.values(state.scores)) rows.push([s.name,s.xu,s.vip]); exportCSV('duck_scores.csv', rows); };
  resetScoreBtn.onclick=()=>{ if(!confirm('Reset to√†n b·ªô b·∫£ng t√≠ch lu·ªπ?')) return; state.scores={}; saveScores(); renderScores(); };

  // ===== Players UI =====
  function perDuckCount(duck){ return state.players.filter(p=>p.duck===duck).length; }
  function redrawPlayers(){
    bodyEl.innerHTML='';
    state.players.forEach((p,idx)=>{
      const tr=document.createElement('tr'); tr.innerHTML = '<td>'+escapeHtml(p.name)+'</td><td>V·ªãt '+p.duck+'</td><td><button data-i="'+idx+'">X</button></td>'; bodyEl.appendChild(tr);
    });
    bodyEl.querySelectorAll('button[data-i]').forEach(btn=>btn.onclick=()=>{const i=+btn.getAttribute('data-i'); state.players.splice(i,1); redrawPlayers(); });
    const counts={}; const n=parseInt(numDucksEl.value||6); for(let i=1;i<=n;i++) counts[i]=0; for(const p of state.players) counts[p.duck]++;
    countInfo.textContent='ƒê·∫∑t c∆∞·ª£c: '+Object.entries(counts).map(([d,c])=>'V·ªãt '+d+': '+c+' (‚â§30)').join(' ¬∑ ');
  }
  function populateDuckOptions(){
    const n = clamp(parseInt(numDucksEl.value||6),3,8);
    duckSelEl.innerHTML=''; for(let i=1;i<=n;i++){ const opt=document.createElement('option'); opt.value=i; opt.textContent='V·ªãt '+i; duckSelEl.appendChild(opt); }
    laneInfo.textContent='S·ªë v·ªãt: '+n+' ¬∑ T·ªëi ƒëa 30 ng∆∞·ªùi/1 v·ªãt';
    redrawPlayers();
    rebuildIdle();
  }
  numDucksEl.addEventListener('change', populateDuckOptions);

  addBtn.onclick=()=>{
    const name=(nameEl.value||'').trim(); const duck=parseInt(duckSelEl.value);
    if(!name) return alert('Nh·∫≠p t√™n/ID'); if(state.players.some(p=>norm(p.name)===norm(name))) return alert('T√™n ƒë√£ c√≥'); if(perDuckCount(duck)>=30) return alert('L√†n v·ªãt '+duck+' ƒë√£ ƒë·ªß 30 ng∆∞·ªùi!');
    state.players.push({name,duck}); nameEl.value=''; redrawPlayers();
  };
  demoBtn.onclick=()=>{
    const n=clamp(parseInt(numDucksEl.value||6),3,8);
    const demo=['An','B√¨nh','C√∫c','D≈©ng','Em','G·∫•u','Huy','Lan','Minh','Nhi','√în','Ph√∫c','Qu√¢n','Rin','S∆°n','T√∫','Uy√™n','V≈©','Xu√¢n','Y·∫øn','Zed'];
    let i=0;
    while(i<demo.length*3){
      const name = demo[i % demo.length] + ' ' + (Math.floor(i/demo.length)+1);
      const duck = (i % n) + 1;
      if(!state.players.some(p=>norm(p.name)===norm(name)) && perDuckCount(duck)<30){ state.players.push({name, duck}); }
      i++; if(perDuckCount(duck)>=30 && state.players.length>= n*30) break;
    }
    redrawPlayers();
  };
  bulkBtn.onclick=()=>{
    const n=parseInt(numDucksEl.value||6);
    (bulkInput.value||'').split(/\r?\n/).forEach(line=>{
      if(!line.trim()) return;
      const [nameRaw,duckRaw]=(line.split(',').map(s=>s.trim()));
      if(!nameRaw||!duckRaw) return;
      const duck=parseInt(duckRaw,10); if(isNaN(duck)||duck<1||duck>n) return;
      if(state.players.some(p=>norm(p.name)===norm(nameRaw))) return;
      if(perDuckCount(duck) >= 30) return;
      state.players.push({name:nameRaw, duck});
    });
    redrawPlayers();
  };
  clearBtn.onclick=()=>{ if(state.raceRunning) return; state.players=[]; redrawPlayers(); };

  // ===== Canvas =====
  let ctx, DPR=1, W=0, H=0;
  function setupCanvas(){
    const rect = canvas.getBoundingClientRect();
    const cssW = Math.max(300, Math.floor(rect.width));
    const cssH = Math.max(280, Math.floor(rect.height));
    DPR = Math.max(1, Math.min(2, window.devicePixelRatio||1));
    canvas.style.width = cssW+'px'; canvas.style.height = cssH+'px';
    canvas.width = Math.floor(cssW * DPR); canvas.height = Math.floor(cssH * DPR);
    W = canvas.width; H = canvas.height;
    ctx = canvas.getContext('2d'); ctx.imageSmoothingEnabled = false;
  }
  window.addEventListener('resize', ()=>{ setupCanvas(); rebuildIdle(); });
  setupCanvas();

  // ===== Visual constants =====
  const SKY_TOP = '#cfe8ff', SKY_BOTTOM='#e8f3ff';
  const LANE_A='#e7f2ff', LANE_B='#f3f8ff';
  const FINISH_TXT = '#1f2937';
  const DUCK_COLORS = ['#ef4444','#f59e0b','#10b981','#3b82f6','#8b5cf6','#f43f5e','#22d3ee','#84cc16'];

  // ===== Draw helpers =====
  function drawGradientSky(){ const g=ctx.createLinearGradient(0,0,0,H); g.addColorStop(0,SKY_TOP); g.addColorStop(1,SKY_BOTTOM); ctx.fillStyle=g; ctx.fillRect(0,0,W,H); }
  function drawTrack(cameraX, lanes){
    drawGradientSky();
    const laneH = H/(lanes+0.5);
    for(let i=0;i<lanes;i++){
      const y=(i+1)*laneH;
      ctx.fillStyle = i%2? LANE_A : LANE_B;
      ctx.fillRect(0, y-laneH*0.45, W, laneH*0.9);
      ctx.strokeStyle='rgba(0,0,0,.06)'; ctx.setLineDash([10*DPR,8*DPR]); ctx.lineWidth=2*DPR;
      ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke();
    }
  }
  function drawFinish(finishVirtX, cameraX){
    const fx = Math.floor((finishVirtX - cameraX));
    if(fx < -20*DPR || fx > W) return;
    for(let y=0;y<H;y+=20*DPR){
      ctx.fillStyle = ((y/20)%2===0)?'#111':'#fff';
      ctx.fillRect(fx, y, 10*DPR, 10*DPR);
      ctx.fillRect(fx+10*DPR, y+10*DPR, 10*DPR, 10*DPR);
    }
    ctx.fillStyle = FINISH_TXT; ctx.font = (14*DPR)+'px system-ui'; ctx.fillText('FINISH', fx-60*DPR, 18*DPR);
  }

  // ===== Image loading =====
  function loadImage(url){
    return new Promise(res=>{
      if(!url){ res(null); return; }
      const img=new Image(); img.crossOrigin='anonymous';
      img.onload=()=>res(img); img.onerror=()=>res(null); img.src=url;
    });
  }
  async function preloadImages(){
    const n = clamp(parseInt(numDucksEl.value||6),3,8);
    state.cache.ducks = new Array(n);
    for(let i=1;i<=n;i++){
      const url = ASSETS.ducks[i] || ASSETS.duckDefault || "";
      state.cache.ducks[i-1] = await loadImage(url);
    }
    state.cache.obstacles = {};
    for(const k of Object.keys(ASSETS.obstacles)){
      state.cache.obstacles[k] = await loadImage(ASSETS.obstacles[k]||"");
    }
  }

  // ===== Effects =====
  const effects=[];
  function spawnBubbles(x,y){ effects.push({type:'bubble',x,y,vx:rand(-30,-10),vy:rand(-10,10),r:rand(2,5)*DPR,life:0,max:700,color:'rgba(255,255,255,.6)'}); }
  function spawnSplash(x,y,color){ for(let i=0;i<10;i++){ effects.push({type:'particle',x,y,vx:rand(-40,40),vy:rand(-20,0),r:rand(2,4)*DPR,life:0,max:500,color}); } }
  function spawnStars(x,y,color='#f59e0b'){ for(let i=0;i<6;i++){ effects.push({type:'star',x,y,vx:rand(-30,30),vy:rand(-10,-30),r:rand(2,3)*DPR,life:0,max:600,color}); } }
  function spawnChevrons(x,y){ for(let i=0;i<6;i++){ effects.push({type:'star',x,y,vx:rand(20,60),vy:rand(-10,10),r:rand(2,3)*DPR,life:0,max:500,color:'#22c55e'}); } }
  function spawnFlames(x,y){ if(!ASSETS.flameOnBoost) return; for(let i=0;i<8;i++){ effects.push({type:'flame',x,y,vx:rand(-60,-20),vy:rand(-20,20),r:rand(2,4)*DPR,life:0,max:450,color1:'#ffdd55',color2:'#ff6b00'}); } }
  function drawEffects(cameraX, dt){
    for(let i=effects.length-1;i>=0;i--){
      const e=effects[i]; e.life+=dt*1000; if(e.life>e.max){effects.splice(i,1); continue;}
      const px=e.x - cameraX, py=e.y;
      if(e.type==='particle'){ ctx.fillStyle=e.color; ctx.beginPath(); ctx.arc(px,py,e.r*(1-e.life/e.max),0,Math.PI*2); ctx.fill(); }
      else if(e.type==='star'){ ctx.fillStyle=e.color; ctx.fillRect(px-1*DPR,py-1*DPR,2*DPR,2*DPR); }
      else if(e.type==='bubble'){ ctx.strokeStyle=e.color; ctx.beginPath(); ctx.arc(px,py,e.r*(1-e.life/e.max*0.6),0,Math.PI*2); ctx.stroke(); }
      else if(e.type==='flame'){
        const t=e.life/e.max, r=e.r*(1-t);
        const g=ctx.createRadialGradient(px,py,0,px,py,r);
        g.addColorStop(0,'#ffdd55'); g.addColorStop(1,'#ff6b00aa');
        ctx.fillStyle=g; ctx.beginPath(); ctx.arc(px,py,r,0,Math.PI*2); ctx.fill();
      }
      e.x+=e.vx*dt; e.y+=e.vy*dt;
    }
  }

  // ===== Draw sprites =====
  function drawObstacleSprite(o, cameraX){
    const px = o.x - cameraX, py = o.y;
    const img = state.cache.obstacles[o.type];
    const w=o.w, h=o.h;
    if(img){ ctx.drawImage(img, px, py, w, h); return; }
    // fallback m√†u + ch·ªØ
    if(o.type==='MUD'){ ctx.fillStyle='#a16207'; }
    else if(o.type==='OIL'){ ctx.fillStyle='#111827'; }
    else if(o.type==='NET'){ ctx.fillStyle='#374151'; }
    else if(o.type==='WAVE'){ ctx.fillStyle='#60a5fa'; }
    else { ctx.fillStyle='#ef4444'; }
    ctx.fillRect(px, py, w, h);
    ctx.fillStyle='#fff'; ctx.font = (10*DPR)+'px system-ui'; ctx.textAlign='center'; ctx.textBaseline='middle';
    const label=(o.type==='MUD'?'M':o.type==='OIL'?'O':o.type==='NET'?'N':o.type==='WAVE'?'W':'C');
    ctx.fillText(label, px+w/2, py+h/2+1*DPR);
  }
  function drawBoostSprite(b, cameraX){
    const px = b.x - cameraX, py = b.y;
    const img = state.cache.obstacles.BOOST;
    if(img){ ctx.drawImage(img, px, py, b.w, b.h); return; }
    ctx.fillStyle='rgba(34,197,94,0.18)'; ctx.fillRect(px, py, b.w, b.h);
    ctx.strokeStyle='rgba(34,197,94,0.9)'; ctx.lineWidth=2*DPR; ctx.strokeRect(px, py, b.w, b.h);
    ctx.fillStyle='#16a34a'; ctx.font=(10*DPR)+'px system-ui'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText('>>', px+b.w/2, py+b.h/2+1*DPR);
  }
  function drawDuckSprite(d, cameraX, now){
    const px = d.x - cameraX;
    const wobble = Math.sin(now/120 + d.lane)* ( (now<d.wobbleUntil)? d.wobbleAmp : 2*DPR );
    const y = d.y + wobble;
    if(now < d.boostUntil) spawnFlames(px-20, y);
    if(Math.random()<0.08) spawnBubbles(px-16 + cameraX, y+6*DPR);
    const img = state.cache.ducks[d.lane];
    const w = ASSETS.duckSize.w*DPR, h = ASSETS.duckSize.h*DPR;
    if(img){ ctx.drawImage(img, px-w/2, y-h/2, w, h); }
    else{
      ctx.fillStyle=d.color; ctx.beginPath(); ctx.ellipse(px, y, 16*DPR, 12*DPR, 0, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(px+14*DPR, y-8*DPR, 8*DPR, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle='#f59e0b'; ctx.fillRect(px+20*DPR, y-8*DPR, 10*DPR, 5*DPR);
      ctx.fillStyle='#111'; ctx.fillRect(px+13*DPR, y-11*DPR, 2*DPR, 2*DPR);
    }
  }

  // ===== Build race =====
  function buildRace(){
    const lanes = clamp(parseInt(numDucksEl.value||6),3,8);
    const laneH = H/(lanes+0.5);
    const startVirtX = Math.floor(W*0.06);
    const baseVisibleLen = (W*0.88 - startVirtX);
    const targetTime = clamp(rand(parseFloat(minTimeEl.value||15), parseFloat(maxTimeEl.value||18)), 5, 160);
    const lengthScale = clamp(targetTime/12, 0.8, 4.2);
    const trackLen = baseVisibleLen * lengthScale;
    const finishVirtX = startVirtX + trackLen;
    const baseSpeed = trackLen / targetTime;

    const ducks=[];
    for(let i=0;i<lanes;i++){
      ducks.push({lane:i,x:startVirtX,y:(i+1)*laneH - laneH*0.2,base: baseSpeed * rand(0.95,1.05),
                  slowUntil:0,freezeUntil:0,wobbleUntil:0,debuffUntil:0,boostUntil:0,
                  wobbleAmp:2*DPR,touched:new Set(),color:DUCK_COLORS[i%DUCK_COLORS.length]});
    }
    // scale obstacles theo th·ªùi gian: base 3, +1 m·ªói 4s v∆∞·ª£t m·ªëc 12s, t·ªëi ƒëa 9
    const baseK=3, extra=Math.max(0, Math.round((targetTime-12)/4)), kClamp=Math.min(9, baseK+extra);
    // boost: base 1, +1 m·ªói ~10s v∆∞·ª£t 12s, t·ªëi ƒëa 3
    const baseB=1, extraB=Math.max(0, Math.round((targetTime-12)/10)), bClamp=Math.min(3, baseB+extraB);

    const types=['MUD','OIL','NET','WAVE','CRAB'];
    const obstacles=[]; const boosts=[];
    for(let i=0;i<lanes;i++){
      for(let j=0;j<kClamp;j++){
        const x = startVirtX + rand(W*0.18, baseVisibleLen*lengthScale - 160*DPR);
        const y = (i+1)*laneH - laneH*0.25;
        const t = types[randi(0, types.length-1)];
        obstacles.push({lane:i, type:t, x, y, w:ASSETS.obstacleSize.w*DPR, h:ASSETS.obstacleSize.h*DPR, id: `${i}-${j}-${t}-${Math.random()}`});
      }
      for(let j=0;j<bClamp;j++){
        const x = startVirtX + rand(W*0.10, baseVisibleLen*lengthScale - 220*DPR);
        const y = (i+1)*laneH - laneH*0.27;
        boosts.push({lane:i, type:'BOOST', x, y, w:ASSETS.boostSize.w*DPR, h:ASSETS.boostSize.h*DPR, id:`B-${i}-${j}-${Math.random()}`});
      }
    }
    return {lanes, laneH, startVirtX, finishVirtX, baseSpeed, ducks, obstacles, boosts, targetTime};
  }

  // ===== Physics & collisions =====
  function tickRace(race, resolve){
    state.raceRunning=true;
    let last = performance.now();
    let cameraX = 0;
    const maxCamera = Math.max(0, race.finishVirtX - W*0.95);
    let winnerLane=-1, startAt=performance.now();

    function duckSpeedMult(d, now){
      let m = 1;
      if(now < d.slowUntil) m *= 0.45;
      if(now < d.debuffUntil) m *= 0.7;
      if(now < d.freezeUntil) m = 0;
      if(now < d.boostUntil) m *= 1.6;
      return m;
    }
    function applyHit(d, obs, now){
      if(obs.type==='MUD'){ d.slowUntil=Math.max(d.slowUntil, now+800); spawnSplash(d.x,d.y,'#a16207'); }
      else if(obs.type==='OIL'){ d.x -= 36*DPR; spawnStars(d.x,d.y-6*DPR); }
      else if(obs.type==='NET'){ d.freezeUntil=Math.max(d.freezeUntil, now+900); spawnSplash(d.x,d.y,'#111827'); }
      else if(obs.type==='WAVE'){ d.wobbleUntil=Math.max(d.wobbleUntil, now+900); d.wobbleAmp=6*DPR; d.slowUntil=Math.max(d.slowUntil, now+500); for(let k=0;k<5;k++)spawnSplash(d.x-10*DPR,d.y,'#60a5fa'); }
      else if(obs.type==='CRAB'){ d.debuffUntil=Math.max(d.debuffUntil, now+1200); spawnStars(d.x,d.y,'#ef4444'); spawnSplash(d.x,d.y,'#ef4444'); }
    }
    function applyBoost(d, pad, now){
      d.boostUntil=Math.max(d.boostUntil, now+900);
      spawnChevrons(d.x,d.y);
      spawnFlames(d.x-16, d.y);
    }
    function rectsOverlap(ax,ay,aw,ah,bx,by,bw,bh){ return ax < bx+bw && ax+aw > bx && ay < by+bh && ay+ah > by; }

    function frame(now){
      const dt = Math.min(0.05, (now - last)/1000); last = now;
      let leaderX = 0;
      for(const d of race.ducks){
        for(const o of race.obstacles){ if(o.lane!==d.lane) continue; const touching = rectsOverlap(d.x-16*DPR, d.y-12*DPR, 32*DPR,24*DPR, o.x,o.y,o.w,o.h); if(touching && !d.touched.has(o.id)){ d.touched.add(o.id); applyHit(d,o,now); } }
        for(const b of race.boosts){ if(b.lane!==d.lane) continue; const touching = rectsOverlap(d.x-16*DPR, d.y-12*DPR, 32*DPR,24*DPR, b.x,b.y,b.w,b.h); if(touching && !d.touched.has(b.id)){ d.touched.add(b.id); applyBoost(d,b,now); } }
        let v = d.base; v *= (0.985 + Math.random()*0.04); if(Math.random()<0.004) v *= 1.35; v *= duckSpeedMult(d, now);
        d.x += v*dt;
        leaderX = Math.max(leaderX, d.x);
        if(d.x >= race.finishVirtX && winnerLane===-1){ winnerLane = d.lane; }
      }
      const targetCam = clamp(leaderX - W*0.55, 0, maxCamera); cameraX += (targetCam - cameraX) * Math.min(1, dt*3.5);
      drawTrack(cameraX, race.lanes);
      drawFinish(race.finishVirtX, cameraX);
      for(const b of race.boosts) drawBoostSprite(b, cameraX);
      for(const o of race.obstacles) drawObstacleSprite(o, cameraX);
      for(const d of race.ducks) drawDuckSprite(d, cameraX, now);
      drawEffects(cameraX, dt);
      if(winnerLane===-1) requestAnimationFrame(frame);
      else { state.raceRunning=false; resolve({winnerLane, time:(now-startAt)/1000, lanes:race.lanes}); }
    }
    requestAnimationFrame(frame);
  }

  // ===== Idle preview (ƒë·ªôi h√¨nh lu√¥n hi·ªÉn th·ªã) =====
  function renderIdle(){
    if(state.raceRunning) { requestAnimationFrame(renderIdle); return; }
    if(!state.idle.race) state.idle.race = buildRace();
    const cam = 0, r = state.idle.race, now=performance.now();
    drawTrack(cam, r.lanes); drawFinish(r.finishVirtX, cam);
    for(const b of r.boosts) drawBoostSprite(b, cam);
    for(const o of r.obstacles) drawObstacleSprite(o, cam);
    for(const d of r.ducks) drawDuckSprite(d, cam, now);
    drawEffects(cam, 0.016);
    requestAnimationFrame(renderIdle);
  }
  function rebuildIdle(){ state.idle.race = buildRace(); }

  // ===== Logging & CSV per race =====
  function groupByDuck(n){ const groups=Array.from({length:n},(_,i)=>({duck:i+1,names:[]})); for(const p of state.players){ if(p.duck>=1 && p.duck<=n) groups[p.duck-1].names.push(p.name); } return groups; }
  function addRaceCSVLink(container, duckNum, winners, groups, timeStr){
    const rows=[['Time', timeStr], ['Winning Duck', '#'+duckNum], [], ['Winner','Xu']];
    if(winners.length){ for(const w of winners) rows.push([w.name, w.xu]); } else { rows.push(['(no winners)','0']); }
    rows.push([]); rows.push(['Group by Duck','Players']);
    for(const g of groups){ rows.push(['Duck #'+g.duck, g.names.join(' | ')||'-']); }
    const csv=rows.map(r=>r.map(v=>`"${String(v).replace(/"/g,'""')}"`).join(',')).join('\r\n');
    const blob=new Blob([csv],{type:'text/csv;charset=utf-8;'}); const url=URL.createObjectURL(blob);
    const a=document.createElement('a'); a.href=url; a.download='duck_race_log.csv'; a.textContent='üì§ Xu·∫•t CSV (ch·∫∑ng n√†y)';
    a.style.marginLeft='6px';
    a.addEventListener('click', ()=>{ setTimeout(()=>URL.revokeObjectURL(url), 2000); });
    container.appendChild(a);
  }
  function logResult(winLane, raceTime, n){
    const duckNum = winLane+1;
    const groups = groupByDuck(n);
    const winnersList = groups[duckNum-1].names;
    const payouts = winnersList.map(nm=>({name:nm, xu:Math.floor(10 + Math.random()*11)})); // 10..20

    // Qu√† b√≠ m·∫≠t (ch·ªâ khi c√≥ ng∆∞·ªùi th·∫Øng)
    let secret=null, secretWinner=null;
    if(winnersList.length>0){
      const r=Math.random();
      if(r < 0.01) secret={type:'VIP'};
      else if(r < 0.03) secret={type:'100XU'};
    }
    if(secret){
      secretWinner = winnersList[Math.floor(Math.random()*winnersList.length)];
      if(secret.type==='100XU'){ const t=payouts.find(p=>p.name===secretWinner); if(t) t.xu += 100; }
    }

    // C·ªông ƒëi·ªÉm
    for(const p of payouts){ addScore(p.name, p.xu, 0); }
    if(secret && secret.type==='VIP' && secretWinner){ addScore(secretWinner, 0, 1); }
    saveScores(); renderScores();

    // Hi·ªÉn th·ªã
    showBanner('V·ªãt #'+duckNum+' th·∫Øng!'); setTimeout(hideBanner, 2000);

    const li=document.createElement('li'); const t=new Date().toLocaleString('vi-VN',{timeZone:TZ});
    const winnersHtml = payouts.length ? payouts.map(p=>escapeHtml(p.name)+' (+'+p.xu+' xu)').join(', ') : '<span class="muted">Kh√¥ng ai ƒë·∫∑t ƒë√∫ng.</span>';
    li.innerHTML = `
      <div><b>${t}</b> ‚Äî V·ªãt <span class="badge win">#${duckNum}</span> th·∫Øng (‚âà ${raceTime.toFixed(2)}s)</div>
      <div class="tiny">Ng∆∞·ªùi th·∫Øng: ${winnersHtml}</div>
      ${secret ? `<div class="tiny">Qu√† b√≠ m·∫≠t: ${secret.type==='VIP'?'VIP':'100 xu'} ‚Üí ${escapeHtml(secretWinner)}</div>`
               : `<div class="tiny muted">Qu√† b√≠ m·∫≠t: kh√¥ng xu·∫•t hi·ªán.</div>`}
      <details><summary>L·ªãch s·ª≠ ƒë·∫∑t c∆∞·ª£c theo nh√≥m (ch·∫∑ng n√†y)</summary>
        <ul>
          ${groups.map(g=> `<li>V·ªãt #${g.duck}: ${g.names.length? g.names.map(n=>escapeHtml(n)).join(', ') : '<span class="muted">‚Äî</span>'}</li>`).join('')}
        </ul>
      </details>
    `;
    logList.prepend(li);

    // n√∫t CSV cho ch·∫∑ng n√†y
    addRaceCSVLink(li.firstElementChild, duckNum, payouts, groups, t);
  }

  // ===== Audio =====
  function ensureAudioContext(){
    if(!state.audioCtx){ const AC=window.AudioContext||window.webkitAudioContext; try{ state.audioCtx=new AC(); }catch{} }
    if(state.audioCtx && state.audioCtx.state==='suspended'){ state.audioCtx.resume().catch(()=>{}); }
  }
  function beep(duration=0.8, freq=660){
    return new Promise(res=>{
      if(!state.audioCtx) return res();
      const osc=state.audioCtx.createOscillator(); const gain=state.audioCtx.createGain();
      osc.type='sine'; osc.frequency.value=freq; gain.gain.value=0.0001;
      osc.connect(gain).connect(state.audioCtx.destination);
      const t=state.audioCtx.currentTime;
      gain.gain.exponentialRampToValueAtTime(0.25,t+0.02);
      gain.gain.exponentialRampToValueAtTime(0.0001,t+duration);
      osc.start(); osc.stop(t+duration+0.02); osc.onended=res;
    });
  }
  function playAudioFileOnce(el){
    return new Promise(res=>{
      let settled=false; const done=()=>{ if(settled) return; settled=true; res(); };
      if(!el){ done(); return; }
      el.currentTime=0; el.loop=false; el.onended=done; el.onerror=done;
      el.play().catch(done);
      setTimeout(done, 2000); // n·∫øu tr√¨nh duy·ªát ch·∫∑n autoplay
    });
  }
  const startBg = el=>{ try{ el&&el.play&&el.play().catch(()=>{});}catch{} };
  const stopBg  = el=>{ try{ if(el){ el.pause(); el.currentTime=0; }}catch{} };

  // ===== Start flow =====
  startBtn.onclick = async ()=>{
    if(state.raceRunning) return;
    ensureAudioContext();
    await preloadImages(); // n·∫°p ·∫£nh t·ª´ ASSETS (fallback n·∫øu l·ªói)

    const nDucks = clamp(parseInt(numDucksEl.value||6),3,8);
    if(state.players.some(p=>p.duck<1 || p.duck>nDucks)) return alert('C√≥ ng∆∞·ªùi ƒë·∫∑t v√†o v·ªãt kh√¥ng t·ªìn t·∫°i.');

    const race = buildRace();
    // lineup preview
    drawTrack(0, race.lanes); drawFinish(race.finishVirtX, 0);
    for(const b of race.boosts) drawBoostSprite(b, 0);
    for(const o of race.obstacles) drawObstacleSprite(o, 0);
    for(const d of race.ducks) drawDuckSprite(d, 0, performance.now());
    showBanner('ƒêang ph√°t intro...');

    state.audio1 = new Audio('1.mp3'); state.audio2 = new Audio('2.mp3'); state.audio1.loop=false; state.audio2.loop=false;

    [startBtn, addBtn, clearBtn, demoBtn, bulkBtn].forEach(b=> b && (b.disabled=true));

    let introDone=false;
    await Promise.race([
      (async ()=>{ await playAudioFileOnce(state.audio1); introDone=true; })(),
      (async ()=>{ await new Promise(r=>setTimeout(r,200)); if(!introDone){ await beep(0.9, 660);} })()
    ]);

    hideBanner(); startBg(state.audio2);

    await new Promise(res=> tickRace(race, res) ).then(result=>{
      stopBg(state.audio2);
      logResult(result.winnerLane, result.time, result.lanes);
    });

    [startBtn, addBtn, clearBtn, demoBtn, bulkBtn].forEach(b=> b && (b.disabled=false));
    rebuildIdle();
  };

  // ===== Init =====
  populateDuckOptions(); loadScores(); preloadImages().then(renderIdle);
})();
</script>
</body>
</html>
