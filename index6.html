<!doctype html>
<html lang="vi">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>ƒêua V·ªãt v3.2 ‚Äî lineup + 30/ng·ªóng + export</title>
<style>
  :root{
    --bg:#f6f7fb; --panel:#ffffff; --text:#0f172a; --muted:#6b7280;
    --border:#e5e7eb; --accent:#2563eb; --good:#16a34a; --warn:#f59e0b; --danger:#ef4444; --boost:#22c55e;
  }
  *{box-sizing:border-box} html,body{margin:0;height:100%;background:var(--bg);color:var(--text);font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial}
  h1,h2{margin:.2rem 0 .6rem}
  .app{display:grid;grid-template-columns:380px 1fr;gap:14px;padding:14px}
  @media (max-width:1200px){.app{grid-template-columns:1fr}}
  .card{background:var(--panel);border:1px solid var(--border);border-radius:14px;padding:14px;box-shadow:0 1px 2px rgba(0,0,0,.03)}
  .row{display:flex;gap:8px;flex-wrap:wrap}
  input,select,textarea{background:#fff;border:1px solid var(--border);color:#0f172a;border-radius:10px;padding:.55rem .65rem;outline:none}
  input,select{flex:1}
  button{background:#1f2937;border:1px solid #111827;color:#fff;border-radius:10px;padding:.6rem .9rem;font-weight:600;cursor:pointer;transition:.15s}
  button.primary{background:linear-gradient(180deg,#3b82f6,#2563eb);border-color:#1d4ed8}
  button.ghost{background:transparent;border-color:var(--border);color:#111827}
  button:active{transform:translateY(1px)}
  table{width:100%;border-collapse:collapse;margin-top:.4rem}
  th,td{border-bottom:1px dashed var(--border);padding:.35rem .25rem}
  th{text-align:left;color:#334155}
  .scroll{max-height:240px;overflow:auto;border:1px solid var(--border);border-radius:10px;padding:.25rem;background:#fff}
  #raceCanvas{width:100%;height:440px;border-radius:12px;display:block;background:linear-gradient(180deg,#cfe8ff,#e8f3ff)}
  #banner{position:absolute;inset:10px;display:flex;align-items:center;justify-content:center;background:rgba(255,255,255,.6);backdrop-filter:blur(4px);border-radius:12px;font-weight:800;font-size:1.2rem;color:#111827;border:1px solid var(--border)}
  .tiny{font-size:.9rem} .muted{color:#6b7280}
  .pill{background:#eef2ff;border:1px solid #c7d2fe;border-radius:999px;padding:.2rem .55rem;color:#3730a3}
  details summary{cursor:pointer;color:#1d4ed8;margin:.3rem 0}
  .badge{display:inline-block;padding:.15rem .5rem;border-radius:999px;font-weight:700;font-size:.8rem;border:1px solid #cbd5e1;background:#f1f5f9}
  .badge.win{background:#ecfdf5;color:#065f46;border-color:#a7f3d0}
  .badge.vip{background:#fef9c3;color:#92400e;border-color:#fde68a}
  .grid{display:grid;grid-template-columns:1fr 1fr;gap:14px}
  @media (max-width:900px){.grid{grid-template-columns:1fr}}
  a.link{color:#2563eb;text-decoration:underline;cursor:pointer}
</style>
</head>
<body>
<div class="app">
  <section class="card">
    <h1>ü¶Ü ƒêua V·ªãt v3.2</h1>
    <div class="row">
      <label style="flex:1.1">S·ªë v·ªãt
        <input id="numDucks" type="number" min="3" max="8" value="6">
      </label>
      <label>Th·ªùi gian (s, 15s+) ‚Äî c√†ng l√¢u, ƒë∆∞·ªùng ƒëua c√†ng d√†i
        <div class="row">
          <input id="minTime" type="number" min="10" max="120" value="15">
          <input id="maxTime" type="number" min="11" max="150" value="18">
        </div>
      </label>
    </div>

    <h2 style="margin-top:.7rem">Ng∆∞·ªùi ch∆°i (t·ªëi ƒëa <b>30 m·ªói v·ªãt</b>)</h2>
    <div class="row">
      <input id="playerName" placeholder="T√™n/ID">
      <select id="duckSelect"></select>
      <button id="addBtn" class="primary">‚ûï Th√™m</button>
      <button id="demoBtn" class="ghost">‚ú® Th√™m demo</button>
    </div>

    <div class="scroll">
      <table>
        <thead><tr><th>Ng∆∞·ªùi ch∆°i</th><th>V·ªãt</th><th></th></tr></thead>
        <tbody id="playersBody"></tbody>
      </table>
    </div>
    <div id="countInfo" class="tiny muted" style="margin-top:.3rem"></div>

    <details>
      <summary>Nh·∫≠p nhanh (m·ªói d√≤ng: <b>t√™n, s·ªë_v·ªãt</b>)</summary>
      <textarea id="bulkInput" placeholder="An, 1&#10;B√¨nh, 3&#10;T√∫n, 2"></textarea>
      <div class="row"><button id="bulkBtn">üì• N·∫°p</button><button id="clearBtn" class="ghost">üßπ Xo√° c∆∞·ª£c</button></div>
    </details>

    <div class="row" style="margin-top:.6rem">
      <button id="startBtn" class="primary">üé¨ B·∫Øt ƒë·∫ßu</button>
      <span class="pill" id="laneInfo">‚Äî</span>
    </div>
    <div class="tiny muted" style="margin-top:.4rem">
      √Çm thanh: ƒë·∫∑t <b>1.mp3</b> / <b>2.mp3</b> chung th∆∞ m·ª•c. N·∫øu thi·∫øu, game t·ª± d√πng ti·∫øng ‚Äúbeep‚Äù.
    </div>
  </section>

  <section class="card" style="position:relative">
    <canvas id="raceCanvas"></canvas>
    <div id="banner" hidden></div>
  </section>
</div>

<div class="grid" style="padding:0 14px 14px">
  <section class="card">
    <h2>üßæ Nh·∫≠t k√Ω th·∫Øng cu·ªôc</h2>
    <div class="tiny muted">M√∫i gi·ªù Asia/Ho_Chi_Minh</div>
    <ul id="logList"></ul>
  </section>
  <section class="card">
    <h2>üìä B·∫£ng t√≠ch lu·ªπ xu</h2>
    <div class="row" style="margin-bottom:.4rem">
      <button id="exportScoreBtn" class="ghost">üì§ Xu·∫•t CSV</button>
      <button id="resetScoreBtn" class="ghost">‚ôªÔ∏è Reset b·∫£ng</button>
    </div>
    <div class="scroll">
      <table>
        <thead><tr><th>Ng∆∞·ªùi ch∆°i</th><th>T·ªïng xu</th><th>VIP</th></tr></thead>
        <tbody id="scoreBody"></tbody>
      </table>
    </div>
  </section>
</div>

<script>
(function(){
  // ===== Elements =====
  const numDucksEl = document.getElementById('numDucks');
  const minTimeEl  = document.getElementById('minTime');
  const maxTimeEl  = document.getElementById('maxTime');
  const nameEl     = document.getElementById('playerName');
  const duckSelEl  = document.getElementById('duckSelect');
  const addBtn     = document.getElementById('addBtn');
  const demoBtn    = document.getElementById('demoBtn');
  const bodyEl     = document.getElementById('playersBody');
  const bulkInput  = document.getElementById('bulkInput');
  const bulkBtn    = document.getElementById('bulkBtn');
  const clearBtn   = document.getElementById('clearBtn');
  const countInfo  = document.getElementById('countInfo');
  const startBtn   = document.getElementById('startBtn');
  const laneInfo   = document.getElementById('laneInfo');
  const canvas     = document.getElementById('raceCanvas');
  const banner     = document.getElementById('banner');
  const logList    = document.getElementById('logList');
  const scoreBody  = document.getElementById('scoreBody');
  const exportScoreBtn = document.getElementById('exportScoreBtn');
  const resetScoreBtn  = document.getElementById('resetScoreBtn');

  // ===== State =====
  const TZ='Asia/Ho_Chi_Minh';
  const LS_KEY='duck_race_v32_scores';
  const state = {
    players: [],
    raceRunning:false,
    audioCtx:null, audio1:null, audio2:null,
    scores: {} // nameLower: {name, xu, vip}
  };

  // ===== Helpers =====
  function clamp(v,a,b){return Math.max(a,Math.min(b,v))}
  function rand(a,b){return a + Math.random()*(b-a)}
  function randi(a,b){return Math.floor(rand(a,b+1))}
  function escapeHtml(s){return s.replace(/[&<>"]/g, c=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;"}[c]))}
  const norm = s => (s||'').trim().toLowerCase();

  function loadScores(){
    try{
      const raw = localStorage.getItem(LS_KEY);
      if(raw) state.scores = JSON.parse(raw) || {};
    }catch{ state.scores={}; }
    renderScores();
  }
  function saveScores(){ try{ localStorage.setItem(LS_KEY, JSON.stringify(state.scores)); }catch{} }
  function addScore(name, deltaXu=0, deltaVip=0){
    const key = norm(name);
    if(!key) return;
    if(!state.scores[key]) state.scores[key] = {name, xu:0, vip:0};
    state.scores[key].name = name;
    state.scores[key].xu += deltaXu;
    state.scores[key].vip += deltaVip;
  }
  function renderScores(){
    const arr = Object.values(state.scores).sort((a,b)=> b.xu-a.xu || b.vip-a.vip || a.name.localeCompare(b.name));
    scoreBody.innerHTML = arr.map(s=> `<tr><td>${escapeHtml(s.name)}</td><td>${s.xu}</td><td>${s.vip}</td></tr>`).join('');
  }
  function exportCSV(filename, rows){
    const csv = rows.map(r => r.map(v=> `"${String(v).replace(/"/g,'""')}"`).join(',')).join('\\r\\n');
    const blob = new Blob([csv], {type:'text/csv;charset=utf-8;'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = filename;
    document.body.appendChild(a); a.click(); a.remove();
    URL.revokeObjectURL(url);
  }
  exportScoreBtn.onclick = ()=>{
    const rows = [['Name','Total Xu','VIP']];
    for(const s of Object.values(state.scores)){ rows.push([s.name, s.xu, s.vip]); }
    exportCSV('duck_scores.csv', rows);
  };
  resetScoreBtn.onclick = ()=>{ if(!confirm('Reset to√†n b·ªô b·∫£ng t√≠ch lu·ªπ?')) return; state.scores={}; saveScores(); renderScores(); };

  function populateDuckOptions(){
    const n = clamp(parseInt(numDucksEl.value||6),3,8);
    duckSelEl.innerHTML='';
    for(let i=1;i<=n;i++){ const opt=document.createElement('option'); opt.value=i; opt.textContent='V·ªãt '+i; duckSelEl.appendChild(opt); }
    laneInfo.textContent='S·ªë v·ªãt: '+n+' ¬∑ T·ªëi ƒëa 30 ng∆∞·ªùi/1 v·ªãt';
    redrawPlayers();
  }
  numDucksEl.addEventListener('change', populateDuckOptions);
  populateDuckOptions();
  loadScores();

  function perDuckCount(duck){ return state.players.filter(p=>p.duck===duck).length; }

  function redrawPlayers(){
    bodyEl.innerHTML='';
    state.players.forEach((p,idx)=>{
      const tr=document.createElement('tr');
      tr.innerHTML = '<td>'+escapeHtml(p.name)+'</td><td>V·ªãt '+p.duck+'</td><td><button data-i="'+idx+'">X</button></td>';
      bodyEl.appendChild(tr);
    });
    bodyEl.querySelectorAll('button[data-i]').forEach(btn=>btn.onclick=()=>{const i=+btn.getAttribute('data-i'); state.players.splice(i,1); redrawPlayers();});
    const counts={}; const n=parseInt(numDucksEl.value||6); for(let i=1;i<=n;i++) counts[i]=0;
    for(const p of state.players) counts[p.duck]++;
    countInfo.textContent = 'ƒê·∫∑t c∆∞·ª£c: '+Object.entries(counts).map(([d,c])=>'V·ªãt '+d+': '+c+' (‚â§30)').join(' ¬∑ ');
  }

  addBtn.onclick=()=>{
    const name=(nameEl.value||'').trim(); const duck=parseInt(duckSelEl.value);
    if(!name) return alert('Nh·∫≠p t√™n/ID');
    if(state.players.some(p=>norm(p.name)===norm(name))) return alert('T√™n ƒë√£ c√≥');
    if(perDuckCount(duck) >= 30) return alert('L√†n v·ªãt '+duck+' ƒë√£ ƒë·ªß 30 ng∆∞·ªùi!');
    state.players.push({name,duck}); nameEl.value=''; redrawPlayers();
  };
  demoBtn.onclick=()=>{
    const n=clamp(parseInt(numDucksEl.value||6),3,8);
    const demo=['An','B√¨nh','C√∫c','D≈©ng','Em','G·∫•u','Huy','Lan','Minh','Nhi','√în','Ph√∫c','Qu√¢n','Rin','S∆°n','T√∫','Uy√™n','V≈©','Xu√¢n','Y·∫øn','Zed'];
    let i=0;
    while(state.players.length< n*30 && i<demo.length*10){
      const name = demo[i % demo.length] + ' ' + (Math.floor(i/demo.length)+1);
      const duck = (i % n) + 1;
      if(!state.players.some(p=>norm(p.name)===norm(name)) && perDuckCount(duck)<30){
        state.players.push({name, duck});
      }
      i++;
      if(i>300) break; // avoid infinite
    }
    redrawPlayers();
  };
  bulkBtn.onclick=()=>{
    const n=parseInt(numDucksEl.value||6);
    (bulkInput.value||'').split(/\\r?\\n/).forEach(line=>{
      if(!line.trim()) return;
      const [nameRaw,duckRaw]=(line.split(',').map(s=>s.trim()));
      if(!nameRaw||!duckRaw) return;
      const duck=parseInt(duckRaw,10); if(isNaN(duck)||duck<1||duck>n) return;
      if(state.players.some(p=>norm(p.name)===norm(nameRaw))) return;
      if(perDuckCount(duck) >= 30) return;
      state.players.push({name:nameRaw, duck});
    });
    redrawPlayers();
  };
  clearBtn.onclick=()=>{ if(state.raceRunning) return; state.players=[]; redrawPlayers(); };

  // ===== Canvas (sharp) =====
  let ctx, DPR=1, W=0, H=0;
  function setupCanvas(){
    const rect = canvas.getBoundingClientRect();
    const cssW = Math.max(300, Math.floor(rect.width));
    const cssH = Math.max(260, Math.floor(rect.height));
    DPR = Math.max(1, Math.min(2, window.devicePixelRatio||1));
    canvas.style.width = cssW+'px'; canvas.style.height = cssH+'px';
    canvas.width = Math.floor(cssW * DPR); canvas.height = Math.floor(cssH * DPR);
    W = canvas.width; H = canvas.height;
    ctx = canvas.getContext('2d'); ctx.imageSmoothingEnabled = false;
    drawTrack(0, parseInt(numDucksEl.value||6));
  }
  window.addEventListener('resize', setupCanvas); setupCanvas();

  // ===== Visual constants =====
  const SKY_TOP = '#cfe8ff', SKY_BOTTOM='#e8f3ff';
  const LANE_A='#e7f2ff', LANE_B='#f3f8ff';
  const FINISH_TXT = '#1f2937';
  const DUCK_COLORS = ['#ef4444','#f59e0b','#10b981','#3b82f6','#8b5cf6','#f43f5e','#22d3ee','#84cc16'];

  function drawGradientSky(){
    const g = ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0, SKY_TOP); g.addColorStop(1, SKY_BOTTOM);
    ctx.fillStyle = g; ctx.fillRect(0,0,W,H);
  }
  function drawTrack(cameraX, lanes){
    drawGradientSky();
    const laneH = H/(lanes+0.5);
    for(let i=0;i<lanes;i++){
      const y=(i+1)*laneH;
      ctx.fillStyle = i%2? LANE_A : LANE_B;
      ctx.fillRect(0, y-laneH*0.45, W, laneH*0.9);
      ctx.strokeStyle='rgba(0,0,0,.06)'; ctx.setLineDash([10*DPR,8*DPR]); ctx.lineWidth=2*DPR;
      ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke();
    }
  }
  function drawFinish(finishVirtX, cameraX){
    const fx = Math.floor((finishVirtX - cameraX));
    if(fx < -20*DPR || fx > W) return;
    for(let y=0;y<H;y+=20*DPR){
      ctx.fillStyle = ((y/20)%2===0)?'#111':'#fff';
      ctx.fillRect(fx, y, 10*DPR, 10*DPR);
      ctx.fillRect(fx+10*DPR, y+10*DPR, 10*DPR, 10*DPR);
    }
    ctx.fillStyle = FINISH_TXT; ctx.font = (14*DPR)+'px system-ui'; ctx.fillText('FINISH', fx-60*DPR, 18*DPR);
  }

  // ===== Audio + fallback =====
  function ensureAudioContext(){
    if(!state.audioCtx){
      const AC = window.AudioContext || window.webkitAudioContext;
      try{ state.audioCtx = new AC(); }catch{}
    }
    if(state.audioCtx && state.audioCtx.state==='suspended'){
      state.audioCtx.resume().catch(()=>{});
    }
  }
  function beep(duration=0.8, freq=660){
    return new Promise(res=>{
      if(!state.audioCtx) return res();
      const osc = state.audioCtx.createOscillator();
      const gain = state.audioCtx.createGain();
      osc.type='sine'; osc.frequency.value=freq;
      gain.gain.value=0.0001;
      osc.connect(gain).connect(state.audioCtx.destination);
      const t = state.audioCtx.currentTime;
      gain.gain.exponentialRampToValueAtTime(0.25, t+0.02);
      gain.gain.exponentialRampToValueAtTime(0.0001, t+duration);
      osc.start(); osc.stop(t+duration+0.02);
      osc.onended=res;
    });
  }
  function playAudioFileOnce(el){
    return new Promise(res=>{
      let settled=false; const done=()=>{ if(settled) return; settled=true; res();};
      if(!el){ done(); return; }
      el.currentTime=0; el.loop=false; el.onended=done; el.onerror=done; el.play().catch(done);
      setTimeout(done, 2000);
    });
  }
  const startBg = el=>{ try{ el&&el.play&&el.play().catch(()=>{});}catch{} };
  const stopBg  = el=>{ try{ if(el){ el.pause(); el.currentTime=0; }}catch{} };

  // ===== Effects =====
  const effects=[];
  function spawnSplash(x,y,color){ for(let i=0;i<10;i++){ effects.push({type:'particle',x,y,vx:rand(-40,40),vy:rand(-20,0),r:rand(2,4)*DPR,life:0,max:500,color}); } }
  function spawnStars(x,y,color='#f59e0b'){ for(let i=0;i<6;i++){ effects.push({type:'star',x,y,vx:rand(-30,30),vy:rand(-10,-30),r:rand(2,3)*DPR,life:0,max:600,color}); } }
  function spawnBubbles(x,y){ effects.push({type:'bubble',x,y,vx:rand(-30,-10),vy:rand(-10,10),r:rand(2,5)*DPR,life:0,max:700,color:'rgba(255,255,255,.6)'}); }
  function spawnChevrons(x,y){ for(let i=0;i<6;i++){ effects.push({type:'star',x,y,vx:rand(20,60),vy:rand(-10,10),r:rand(2,3)*DPR,life:0,max:500,color:'#22c55e'}); } }
  function drawEffects(cameraX, dt){
    for(let i=effects.length-1;i>=0;i--){
      const e=effects[i]; e.life+=dt*1000; if(e.life>e.max){effects.splice(i,1); continue;}
      const px=e.x - cameraX, py=e.y;
      if(e.type==='particle'){ ctx.fillStyle=e.color; ctx.beginPath(); ctx.arc(px,py,e.r*(1-e.life/e.max),0,Math.PI*2); ctx.fill(); }
      else if(e.type==='star'){ ctx.fillStyle=e.color; ctx.fillRect(px-1*DPR,py-1*DPR,2*DPR,2*DPR); }
      else if(e.type==='bubble'){ ctx.strokeStyle=e.color; ctx.beginPath(); ctx.arc(px,py,e.r*(1-e.life/e.max*0.6),0,Math.PI*2); ctx.stroke(); }
      e.x+=e.vx*dt; e.y+=e.vy*dt;
    }
  }

  // ===== Build race data so we can preview lineup BEFORE audio =====
  function buildRace(){
    const lanes = parseInt(numDucksEl.value||6);
    const laneH = H/(lanes+0.5);
    const startVirtX = Math.floor(W*0.06);
    const baseVisibleLen = (W*0.88 - startVirtX);
    const targetTime = clamp(rand(parseFloat(minTimeEl.value||15), parseFloat(maxTimeEl.value||18)), 5, 150);
    const lengthScale = clamp(targetTime/12, 0.8, 3.5);
    const trackLen = baseVisibleLen * lengthScale;
    const finishVirtX = startVirtX + trackLen;
    const baseSpeed = trackLen / targetTime;

    const ducks=[];
    for(let i=0;i<lanes;i++){
      ducks.push({lane:i,x:startVirtX,y:(i+1)*laneH - laneH*0.2,base: baseSpeed * rand(0.95,1.05),
                  slowUntil:0,freezeUntil:0,wobbleUntil:0,debuffUntil:0,boostUntil:0,
                  wobbleAmp:2*DPR,touched:new Set(),color:DUCK_COLORS[i%DUCK_COLORS.length]});
    }

    const types=['MUD','OIL','NET','WAVE','CRAB'];
    const obstacles=[]; const boosts=[];
    for(let i=0;i<lanes;i++){
      const k=randi(3,5);
      for(let j=0;j<k;j++){
        const x = rand(W*0.22, finishVirtX - 160*DPR);
        const y = (i+1)*laneH - laneH*0.25;
        const t = types[randi(0, types.length-1)];
        obstacles.push({lane:i, type:t, x, y, w:28*DPR, h:28*DPR, id: `${i}-${j}-${t}`});
      }
      const bcount=randi(1,2);
      for(let j=0;j<bcount;j++){
        const x = rand(W*0.16, finishVirtX - 220*DPR);
        const y = (i+1)*laneH - laneH*0.27;
        boosts.push({lane:i, type:'BOOST', x, y, w:34*DPR, h:20*DPR, id:`B-${i}-${j}`});
      }
    }
    return {lanes, laneH, startVirtX, finishVirtX, baseSpeed, ducks, obstacles, boosts, targetTime};
  }

  function drawObstacles(cameraX, obstacles){
    ctx.textBaseline='middle'; ctx.textAlign='center';
    for(const o of obstacles){
      const px = o.x - cameraX; const py = o.y;
      if(px < -60*DPR || px > W+60*DPR) continue;
      if(o.type==='MUD'){ ctx.fillStyle='#a16207'; }
      else if(o.type==='OIL'){ ctx.fillStyle='#111827'; }
      else if(o.type==='NET'){ ctx.fillStyle='#374151'; }
      else if(o.type==='WAVE'){ ctx.fillStyle='#60a5fa'; }
      else { ctx.fillStyle='#ef4444'; }
      ctx.fillRect(px, py, o.w, o.h);
      ctx.fillStyle='#fff'; ctx.font = (10*DPR)+'px system-ui';
      const label = (o.type==='MUD'?'M':o.type==='OIL'?'O':o.type==='NET'?'N':o.type==='WAVE'?'W':'C');
      ctx.fillText(label, px + o.w/2, py + o.h/2 + 1*DPR);
    }
  }
  function drawBoosts(cameraX, boosts){
    ctx.textBaseline='middle'; ctx.textAlign='center';
    for(const b of boosts){
      const px = b.x - cameraX; const py = b.y;
      if(px < -80*DPR || px > W+80*DPR) continue;
      ctx.fillStyle='rgba(34,197,94,0.18)'; ctx.fillRect(px, py, b.w, b.h);
      ctx.strokeStyle='rgba(34,197,94,0.9)'; ctx.lineWidth=2*DPR; ctx.strokeRect(px, py, b.w, b.h);
      ctx.fillStyle='#16a34a'; ctx.font=(10*DPR)+'px system-ui'; ctx.fillText('>>', px + b.w/2, py + b.h/2 + 1*DPR);
    }
  }
  function drawDucks(cameraX, ducks, now, wobble=true){
    for(const d of ducks){
      const baseY = d.y + (wobble ? Math.sin(now/120 + d.lane)* d.wobbleAmp : 0);
      const px = d.x - cameraX;
      if(Math.random()<0.12) spawnBubbles(px-16*DPR + cameraX, baseY+6*DPR);
      ctx.fillStyle=d.color;
      ctx.beginPath(); ctx.ellipse(px, baseY, 16*DPR, 12*DPR, 0, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(px+14*DPR, baseY-8*DPR, 8*DPR, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle='#f59e0b'; ctx.fillRect(px+20*DPR, baseY-8*DPR, 10*DPR, 5*DPR);
      ctx.fillStyle='#111'; ctx.fillRect(px+13*DPR, baseY-11*DPR, 2*DPR, 2*DPR);
    }
  }

  // Show lineup immediately on Start (before waiting audio)
  function previewLineup(race){
    const cameraX = 0;
    drawTrack(cameraX, race.lanes);
    drawFinish(race.finishVirtX, cameraX);
    drawBoosts(cameraX, race.boosts);
    drawObstacles(cameraX, race.obstacles);
    drawDucks(cameraX, race.ducks, performance.now(), false);
  }

  // Run the race on the already built data
  function runRace(race){
    return new Promise(resolve=>{
      state.raceRunning=true; banner.hidden=true;
      let last = performance.now();
      let cameraX = 0;
      const maxCamera = Math.max(0, race.finishVirtX - W*0.95);
      let winnerLane=-1, startAt=performance.now();

      function duckSpeedMult(d, now){
        let m = 1;
        if(now < d.slowUntil) m *= 0.45;
        if(now < d.debuffUntil) m *= 0.7;
        if(now < d.freezeUntil) m = 0;
        if(now < d.boostUntil) m *= 1.6;
        return m;
      }
      function applyHit(d, obs, now){
        if(obs.type==='MUD'){ d.slowUntil=Math.max(d.slowUntil, now+800); spawnSplash(d.x,d.y,'#a16207'); }
        else if(obs.type==='OIL'){ d.x -= 36*DPR; spawnStars(d.x,d.y-6*DPR); }
        else if(obs.type==='NET'){ d.freezeUntil=Math.max(d.freezeUntil, now+900); spawnSplash(d.x,d.y,'#111827'); }
        else if(obs.type==='WAVE'){ d.wobbleUntil=Math.max(d.wobbleUntil, now+900); d.wobbleAmp=6*DPR; d.slowUntil=Math.max(d.slowUntil, now+500); for(let k=0;k<5;k++)spawnSplash(d.x-10*DPR,d.y,'#60a5fa'); }
        else if(obs.type==='CRAB'){ d.debuffUntil=Math.max(d.debuffUntil, now+1200); spawnStars(d.x,d.y,'#ef4444'); spawnSplash(d.x,d.y,'#ef4444'); }
      }
      function applyBoost(d, pad, now){ d.boostUntil=Math.max(d.boostUntil, now+900); spawnChevrons(d.x,d.y); }

      function tick(now){
        const dt = Math.min(0.05, (now - last)/1000); last = now;
        let leaderX = 0;
        for(const d of race.ducks){
          for(const o of race.obstacles){ if(o.lane!==d.lane) continue; const touching = (d.x-16*DPR) < (o.x+o.w) && (d.x+16*DPR) > o.x && (d.y-12*DPR) < (o.y+o.h) && (d.y+12*DPR) > o.y; if(touching && !d.touched.has(o.id)){ d.touched.add(o.id); applyHit(d,o,now); } }
          for(const b of race.boosts){ if(b.lane!==d.lane) continue; const touching = (d.x-16*DPR) < (b.x+b.w) && (d.x+16*DPR) > b.x && (d.y-12*DPR) < (b.y+b.h) && (d.y+12*DPR) > b.y; if(touching && !d.touched.has(b.id)){ d.touched.add(b.id); applyBoost(d,b,now); } }
          let v = d.base; v *= (0.985 + Math.random()*0.04); if(Math.random()<0.004) v *= 1.35; v *= duckSpeedMult(d, now);
          d.x += v*dt;
          leaderX = Math.max(leaderX, d.x);
          if(d.x >= race.finishVirtX && winnerLane===-1){ winnerLane = d.lane; }
        }
        const targetCam = clamp(leaderX - W*0.55, 0, maxCamera); cameraX += (targetCam - cameraX) * Math.min(1, dt*3.5);
        drawTrack(cameraX, race.lanes);
        drawFinish(race.finishVirtX, cameraX);
        drawBoosts(cameraX, race.boosts);
        drawObstacles(cameraX, race.obstacles);
        drawDucks(cameraX, race.ducks, now, true);
        drawEffects(cameraX, dt);
        if(winnerLane===-1) requestAnimationFrame(tick);
        else { state.raceRunning=false; resolve({winnerLane, time:(now-startAt)/1000, lanes:race.lanes}); }
      }
      requestAnimationFrame(tick);
    });
  }

  // ===== Grouping & logging (as in v3.1) =====
  function groupByDuck(n){
    const groups = Array.from({length:n}, (_,i)=>({duck:i+1, names:[]}));
    for(const p of state.players){ if(p.duck>=1 && p.duck<=n) groups[p.duck-1].names.push(p.name); }
    return groups;
  }
  function logResult(winLane, raceTime, n){
    const duckNum = winLane+1;
    const groups = groupByDuck(n);
    const winners = groups[duckNum-1].names;
    const randi=(a,b)=>Math.floor(a + Math.random()*(b-a+1));
    const payouts = winners.map(nm=>({name:nm, xu:randi(10,20)}));

    let secret=null, secretWinner=null;
    if(winners.length>0){
      const r=Math.random();
      if(r < 0.01) secret={type:'VIP'};
      else if(r < 0.03) secret={type:'100XU'};
    }
    if(secret){
      secretWinner = winners[Math.floor(Math.random()*winners.length)];
      if(secret.type==='100XU'){
        const t = payouts.find(p=>p.name===secretWinner);
        if(t) t.xu += 100;
      }
    }

    for(const p of payouts){ addScore(p.name, p.xu, 0); }
    if(secret && secret.type==='VIP' && secretWinner){ addScore(secretWinner, 0, 1); }
    saveScores(); renderScores();

    banner.innerHTML = 'V·ªãt <span class="badge win">#'+duckNum+'</span> th·∫Øng!'; banner.hidden=false; setTimeout(()=>banner.hidden=true, 2300);

    const groupHtml = groups.map(g=>{
      const list = g.names.length? g.names.map(n=>escapeHtml(n)).join(', ') : '<span class="muted">‚Äî</span>';
      return '<li>V·ªãt #'+g.duck+': '+list+'</li>';
    }).join('');

    const li=document.createElement('li');
    const t = new Date().toLocaleString('vi-VN',{timeZone:TZ});
    li.innerHTML = `
      <div><b>${t}</b> ‚Äî V·ªãt <span class="badge win">#${duckNum}</span> th·∫Øng (‚âà ${raceTime.toFixed(2)}s)</div>
      <div class="tiny">Ng∆∞·ªùi th·∫Øng: ${payouts.length ? payouts.map(p=>escapeHtml(p.name)+' (+'+p.xu+' xu)').join(', ') : '<span class="muted">Kh√¥ng ai ƒë·∫∑t ƒë√∫ng.</span>'}</div>
      ${secret ? `<div class="tiny">Qu√† b√≠ m·∫≠t: ${secret.type==='VIP'?'VIP':'100 xu'} ‚Üí ${escapeHtml(secretWinner)}</div>`
               : `<div class="tiny muted">Qu√† b√≠ m·∫≠t: kh√¥ng xu·∫•t hi·ªán.</div>`}
      <details><summary>L·ªãch s·ª≠ ƒë·∫∑t c∆∞·ª£c theo nh√≥m (ch·∫∑ng n√†y)</summary>
        <ul>${groupHtml}</ul>
      </details>
    `;
    logList.prepend(li);
  }

  // ===== Start flow =====
  startBtn.onclick = async ()=>{
    if(state.raceRunning) return;
    ensureAudioContext();

    const nDucks = clamp(parseInt(numDucksEl.value||6),3,8);
    if(state.players.some(p=>p.duck<1 || p.duck>nDucks)) return alert('C√≥ ng∆∞·ªùi ƒë·∫∑t v√†o v·ªãt kh√¥ng t·ªìn t·∫°i.');

    // Build race first -> preview lineup immediately
    const race = buildRace();
    previewLineup(race);

    state.audio1 = new Audio('1.mp3'); state.audio1.loop=false;
    state.audio2 = new Audio('2.mp3'); state.audio2.loop=false;

    // Disable inputs
    [startBtn, addBtn, clearBtn, demoBtn, bulkBtn].forEach(b=> b && (b.disabled=true));

    // Intro (play 1.mp3 or beep) while lineup is visible
    let introDone=false;
    await Promise.race([
      (async ()=>{ await playAudioFileOnce(state.audio1); introDone=true; })(),
      (async ()=>{ await new Promise(r=>setTimeout(r,200)); if(!introDone){ await beep(1.0, 660);} })()
    ]);

    // Start bg
    startBg(state.audio2);

    // Run race
    const result = await runRace(race);

    // Stop & reset bg
    stopBg(state.audio2);

    // Log
    logResult(result.winnerLane, result.time, result.lanes);

    [startBtn, addBtn, clearBtn, demoBtn, bulkBtn].forEach(b=> b && (b.disabled=false));
  };

})();</script>
</body>
</html>
